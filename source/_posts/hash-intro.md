---
title: 哈希简介及冲突处理
categories:
  - 技术
tags:
  - 算法
abbrlink: '97310931'
date: 2019-07-19 14:51:35
---

# 简介
根据维基百科介绍，散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表，好的散列函数在输入域中很少出现散列冲突。

# 性质
所有散列函数都有如下一个基本特性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为单向散列函数。但另一方面，散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为“散列碰撞（collision）”，这通常是两个不同长度的输入值，刻意计算出相同的输出值。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。

典型的散列函数都有非常大的定义域，比如SHA-2最高接受(264-1)/8长度的字节字符串。同时散列函数一定有着有限的值域，比如固定长度的比特串。在某些情况下，散列函数可以设计成具有相同大小的定义域和值域间的单射。在密码学中，散列函数必须具有不可逆性。

# 解决哈希冲突的方法
由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，因此总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突。

解决哈希冲突一般有以下几种方法：
* 开放定址法
* 链地址法（拉链法）
* 再哈希法
* 建立公共溢出区

## 开放定址法
从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。

在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。
开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误（查找到空的时候，结束查找，这样当前删除的元素后的数据就不会再匹配查找了），只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。

### 线性探查法
线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。

### 平方探查法
平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上或减去 1²、 2²等。即d[i] +- 1²，d[i] +- 2², d[i] +- 3²...直到找到空闲单元。
在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。

### 双散列函数探查法
**使用双散列方法可以避免二级聚集。双散列法使用两个散列函数，第一个散列函数计算探针序列的起始值，第二个散列函数计算下一个位置的探查步长。**

这种方法使用两个散列函数 hl 和 h2。其中 hl 和前面的 h 一样，以关键字为自变量，产生一个 0 m—l 之间的数作为散列地址；h2 也以关键字为自变量，产生一个 l 至 m—1 之间的、并和 m 互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值 l；对于平方探查法，探查序列的步长值是探查次数i的两倍减 l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。

## 链地址法（拉链法）
链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。
如一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为 13，哈希函数为 H(key) = key % 13,则链表法结果如下：

```
0       
1  -> 40 -> 27 -> 53 
2
3  -> 16 -> 42
4
5
6  -> 32 -> 71
7  -> 46
8
9
10 -> 36 -> 49
11 -> 24
12 -> 64
```

> 注：在java中，链接地址法也是HashMap解决哈希冲突的方法之一，jdk1.7完全采用单链表来存储同义词，jdk1.8则采用了一种混合模式，对于链表长度大于8的，会转换为红黑树存储。

## 再哈希法
就是同时构造多个不同的哈希函数：
Hi = RHi(key) i= 1,2,3 ... k;
当 H1 = RH1(key) 发生冲突时，再用 H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。

## 建立公共溢出区
将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。

# 参考
* [哈希函数-维基百科](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8)
* [解决哈希冲突的方法](https://www.jianshu.com/p/4d3cb99d7580)