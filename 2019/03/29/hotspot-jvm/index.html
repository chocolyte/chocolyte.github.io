<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JVM,">










<meta name="description" content="垃圾收集概念GC 需要做 3 件事情：  分配内存，为每个新建的对象分配空间 确保还在使用的对象的内存一直还在，不能把有用的空间当垃圾回收了 释放不再使用的对象所占用的空间我们把还被 GC Roots 引用的对象称为活的，把不再被引用的对象认为是死的，也就是我们说的垃圾，GC 的工作就是找到死的对象，回收它们占用的空间。在这里，我们总结一下 GC Roots 有哪些： 当前各线程执行方法中的局部变">
<meta name="keywords" content="JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="hotspot-jvm">
<meta property="og:url" content="http://peach.ren/2019/03/29/hotspot-jvm/index.html">
<meta property="og:site_name" content="Peach`s Blog">
<meta property="og:description" content="垃圾收集概念GC 需要做 3 件事情：  分配内存，为每个新建的对象分配空间 确保还在使用的对象的内存一直还在，不能把有用的空间当垃圾回收了 释放不再使用的对象所占用的空间我们把还被 GC Roots 引用的对象称为活的，把不再被引用的对象认为是死的，也就是我们说的垃圾，GC 的工作就是找到死的对象，回收它们占用的空间。在这里，我们总结一下 GC Roots 有哪些： 当前各线程执行方法中的局部变">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://www.javadoop.com/blogimages/jvm-memory-management/3.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/jvm-memory-management/4.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/jvm-memory-management/5.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/jvm-memory-management/6.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/jvm-memory-management/7.png">
<meta property="og:image" content="https://www.javadoop.com/blogimages/jvm-memory-management/8.png">
<meta property="og:image" content="http://note.youdao.com/yws/res/18836/51D70BBADA52441594797E8CD748FCA8">
<meta property="og:updated_time" content="2019-03-29T08:05:25.012Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hotspot-jvm">
<meta name="twitter:description" content="垃圾收集概念GC 需要做 3 件事情：  分配内存，为每个新建的对象分配空间 确保还在使用的对象的内存一直还在，不能把有用的空间当垃圾回收了 释放不再使用的对象所占用的空间我们把还被 GC Roots 引用的对象称为活的，把不再被引用的对象认为是死的，也就是我们说的垃圾，GC 的工作就是找到死的对象，回收它们占用的空间。在这里，我们总结一下 GC Roots 有哪些： 当前各线程执行方法中的局部变">
<meta name="twitter:image" content="https://www.javadoop.com/blogimages/jvm-memory-management/3.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://peach.ren/2019/03/29/hotspot-jvm/">





  <title>hotspot-jvm | Peach`s Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Peach`s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://peach.ren/2019/03/29/hotspot-jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zeusoul">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Peach`s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">hotspot-jvm</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-29T13:52:44+08:00">
                2019-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="垃圾收集概念"><a href="#垃圾收集概念" class="headerlink" title="垃圾收集概念"></a>垃圾收集概念</h1><p>GC 需要做 3 件事情：</p>
<ul>
<li>分配内存，为每个新建的对象分配空间</li>
<li>确保还在使用的对象的内存一直还在，不能把有用的空间当垃圾回收了</li>
<li>释放不再使用的对象所占用的空间<br>我们把还被 GC Roots 引用的对象称为活的，把不再被引用的对象认为是死的，也就是我们说的垃圾，GC 的工作就是找到死的对象，回收它们占用的空间。<br>在这里，我们总结一下 GC Roots 有哪些：</li>
<li>当前各线程执行方法中的局部变量（包括形参）引用的对象</li>
<li>已被加载的类的 static 域引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>JNI 引用<br>我们把 GC 管理的内存称为 堆（heap），垃圾收集启动的时机取决于各个垃圾收集器，通常，垃圾收集发生于整个堆或堆的部分已经被使用光了，或者使用的空间达到了某个百分比阈值。这些后面都会具体说，这里的每一句话都是对应了某些场景的。</li>
</ul>
<p>对于内存分配请求，实现的难点在于在堆中找到一块没有被使用的确定大小的内存空间。所以，对于大部分垃圾回收算法来说避免内存碎片化是非常重要的，它将使得空间分配更加高效。</p>
<h2 id="垃圾收集器的理想特征"><a href="#垃圾收集器的理想特征" class="headerlink" title="垃圾收集器的理想特征"></a>垃圾收集器的理想特征</h2><ol>
<li>安全和全面：活的对象一定不能被清理掉，死的对象一定不能在几个回收周期结束后还在内存中。</li>
<li>高效：不能将我们的应用程序挂起太长时间。我们需要在时间、空间、频次上作出权衡。比如，如果堆内存很小，每次垃圾收集就会很快，但是频次会增加。如果堆内存很大，很久才会被填满，但是每一次回收需要的时间很长</li>
<li>尽量少的内存碎片：每次将垃圾对象释放以后，这些空间可能分布在各个地方，最糟糕的情况就是，内存中到处都是碎片，在给一个大对象分配空间的时候没有内存可用，实际上内存是够的。消除碎片的方式就是压缩</li>
<li>可扩展性：在多核多线程应用中，内存分配和垃圾回收都不应该成为可扩展性的瓶颈。原文提到的这一点，我的理解是：单线程垃圾回收在多核系统中会浪费 CPU 资源<h2 id="设计上的权衡"><a href="#设计上的权衡" class="headerlink" title="设计上的权衡"></a>设计上的权衡</h2>往下看之前，我们需要先分清楚这里的两个概念：并发和并行</li>
</ol>
<ul>
<li>并行：多个垃圾回收线程同时工作，而不是只有一个垃圾回收线程在工作</li>
<li>并发：垃圾回收线程和应用程序线程同时工作，应用程序不需要挂起<br>在设计或选择垃圾回收算法的时候，我们需要作出以下几个权衡：</li>
<li>串行 vs 并行<br>串行收集的情况，即使是多核 CPU，也只有一个核心参与收集。使用并行收集器的话，垃圾收集的工作将分配给多个线程在不同的 CPU 上同时进行。并行可以让收集工作更快，缺点是带来的复杂性和内存碎片问题。</li>
<li>并发 vs Stop-the-world<br>当 stop-the-world 垃圾收集器工作的时候，应用将完全被挂起。与之相对的，并发收集器在大部分工作中都是并发进行的，也许会有少量的 stop-the-world。</li>
</ul>
<p>stop-the-world 垃圾收集器比并发收集器简单很多，因为应用挂起后堆空间不再发生变化，它的缺点是在某些场景下挂起的时间我们是不能接受的（如 web 应用）。</p>
<p>相应的，并发收集器能够降低挂起时间，但是也更加复杂，因为在收集的过程中，也会有新的垃圾产生，同时，需要有额外的空间用于在垃圾收集过程中应用程序的继续使用。</p>
<ul>
<li>压缩 vs 不压缩 vs 复制<br>当垃圾收集器标记出内存中哪些是活的，哪些是垃圾对象后，收集器可以进行压缩，将所有活的对象移到一起，这样新的内存分配就可以在剩余的空间中进行了。经过压缩后，分配新对象的内存空间是非常简单快速的。</li>
</ul>
<p>相对的，不压缩的收集器只会就地释放空间，不会移动存活对象。优点就是快速完成垃圾收集，缺点就是潜在的碎片问题。通常，这种情况下，分配对象空间会比较慢比较复杂，比如为新的一个大对象找到合适的空间。</p>
<p>还有一个选择就是复制收集器，将活的对象复制到另一块空间中，优点就是原空间被清空了，这样后续分配对象空间非常迅速，缺点就是需要进行复制操作和占用额外的空间。</p>
<h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><ul>
<li>吞吐量：应用程序的执行时间占总时间的百分比，当然是越高越好</li>
<li>垃圾收集开销：垃圾收集时间占总时间的百分比（1 - 吞吐量）</li>
<li>停顿时间：垃圾收集过程中导致的应用程序挂起时间</li>
<li>频次：相对于应用程序来说，垃圾收集的频次</li>
<li>空间：垃圾收集占用的内存</li>
<li>及时性：一个对象从成为垃圾到该对象空间再次可用的时间<br>在交互式程序中，通常希望是低延时的，而对于非交互式程序，总运行时间比较重要。实时应用程序既要求每次停顿时间足够短，也要求总的花费在收集的时间足够短。在小型个人计算机和嵌入式系统中，则希望占用更小的空间。</li>
</ul>
<h2 id="分代收集介绍"><a href="#分代收集介绍" class="headerlink" title="分代收集介绍"></a>分代收集介绍</h2><p>当我们使用分代垃圾收集器时，内存将被分为不同的代(generation)，最常见的就是分为年轻代和老年代。</p>
<p>在不同的分代中，可以根据不同的特点使用不同的算法。分代垃圾收集基于 weak generational hypothesis 假设（即「弱分代」假设）：</p>
<ul>
<li>大部分对象都是短命的，它们在年轻的时候就会死去</li>
<li>极少老年对象对年轻对象的引用</li>
<li>年轻代中的收集是非常频繁的、高效的、快速的，因为年轻代空间中，通常都是小对象，同时有非常多的不再被引用的对象。</li>
</ul>
<p>那些经历过多次年轻代垃圾收集还存活的对象会晋升到老年代中，老年代的空间更大，而且占用空间增长比较慢。这样，老年代的垃圾收集是不频繁的，但是进行一次垃圾收集需要的时间更长。</p>
<p>对于新生代，需要选择速度比较快的垃圾回收算法，因为新生代的垃圾回收是频繁的。</p>
<p>对于老年代，需要考虑的是空间，因为老年代占用了大部分堆内存，而且针对该部分的垃圾回收算法，需要考虑到这个区域的垃圾密度比较低。</p>
<h1 id="J2SE-5-0-HotSpot-JVM-中的垃圾收集器"><a href="#J2SE-5-0-HotSpot-JVM-中的垃圾收集器" class="headerlink" title="J2SE 5.0 HotSpot JVM 中的垃圾收集器"></a>J2SE 5.0 HotSpot JVM 中的垃圾收集器</h1><p>J2SE 5.0 HotSpot 虚拟机包含四种垃圾收集器，都是采用分代算法。包括串行收集器、并行收集器、并行压缩收集器 和 CMS 垃圾收集器。</p>
<h2 id="HotSpot-分代"><a href="#HotSpot-分代" class="headerlink" title="HotSpot 分代"></a>HotSpot 分代</h2><p>在 HotSpot 虚拟机中，内存被组织成三个分代：年轻代、老年代、永久代。</p>
<p>大部分对象初始化的时候都是在年轻代中的。</p>
<p>老年代存放经过了几次年轻代垃圾收集依然还活着的对象，还有部分大对象因为比较大所以分配的时候直接在老年代分配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如 -XX:PretenureSizeThreshold=1024，这样大于 1k 的对象就会直接分配在老年代</span><br></pre></td></tr></table></figure>
<p>永久代，通常也叫 方法区，用于存储已加载类的元数据，以及存储运行时常量池等。</p>
<h2 id="垃圾回收类型"><a href="#垃圾回收类型" class="headerlink" title="垃圾回收类型"></a>垃圾回收类型</h2><p>当年轻代被填满后，会进行一次年轻代垃圾收集（也叫做 minor GC）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：&quot;minor gc 收集年轻代，full gc 收集老年代&quot; 这句话是错的。</span><br></pre></td></tr></table></figure>
<p>当老年代或永久代被填满了，会触发 full GC（也叫做 major GC），full GC 会收集所有区域，先进行年轻代的收集，使用年轻代专用的垃圾回收算法，然后使用老年代的垃圾回收算法回收老年代和永久代。如果算法带有压缩，每个代分别独立地进行压缩。</p>
<p>如果先进行年轻代垃圾收集，会使得老年代不能容纳要晋升上来的对象，这种情况下，不会先进行 young gc，所有的收集器都会（除了 CMS）直接采用老年代收集算法对整个堆进行收集（CMS 收集器比较特殊，因为它不能收集年轻代的垃圾）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于统计，计算出每次年轻代晋升到老年代的平均大小，if (老年代剩余空间 &lt; 平均大小) 触发 full gc。</span><br></pre></td></tr></table></figure>
<h2 id="快速分配"><a href="#快速分配" class="headerlink" title="快速分配"></a>快速分配</h2><p>如果垃圾收集完成后，存在大片连续的内存可用于分配给新对象，这种情况下分配空间是非常简单快速的，只要一个简单的指针碰撞就可以了（bump-the-pointer），每次分配对象空间只要检测一下是否有足够的空间，如果有，指针往前移动 N 位就分配好空间了，然后就可以初始化这个对象了。</p>
<p>对于多线程应用，对象分配必须要保证线程安全性，如果使用全局锁，那么分配空间将成为瓶颈并降低程序性能。HotSpot 使用了称之为 Thread-Local Allocation Buffers (TLABs) 的技术，该技术能改善多线程空间分配的吞吐量。首先，给予每个线程一部分内存作为缓存区，每个线程都在自己的缓存区中进行指针碰撞，这样就不用获取全局锁了。只有当一个线程使用完了它的 TLAB，它才需要使用同步来获取一个新的缓冲区。HotSpot 使用了多项技术来降低 TLAB 对于内存的浪费。比如，TLAB 的平均大小被限制在 Eden 区大小的 1% 之内。TLABs 和使用指针碰撞的线性分配结合，使得内存分配非常简单高效，只需要大概 10 条机器指令就可以完成。</p>
<h2 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h2><p>使用串行收集器，年轻代和老年代都使用单线程进行收集（使用一个 CPU），收集过程中会 stop-the-world。所以当在垃圾收集的时候，应用程序是完全停止的。</p>
<h3 id="年轻代中使用串行收集器"><a href="#年轻代中使用串行收集器" class="headerlink" title="年轻代中使用串行收集器"></a>年轻代中使用串行收集器</h3><p>下图展示了年轻代中使用串行收集器的流程。<br><img src="https://www.javadoop.com/blogimages/jvm-memory-management/3.png" alt></p>
<p>年轻代分为一个 Eden 区和两个 Survivor 区（From 区和 To 区）。年轻代垃圾收集时，将 Eden 中活着的对象复制到空的 Survivor-To 区，Survivor-From 区的对象分两类，一类是年轻的，也是复制到 Survivor-To 区，还有一类是老家伙，晋升到老年代中。</p>
<p>如果复制的过程中，发现 Survivor-To 空间满了，将剩下还没复制到 Survivor-To 的来自于 Eden 和 Survivor-From 区的对象直接晋升到老年代。</p>
<p>年轻代垃圾收集完成后，Eden 区和 Survivor-From 就干净了，此时，将 Survivor-From 和 Survivor-To 交换一下角色。得到下面这个样子：</p>
<p><img src="https://www.javadoop.com/blogimages/jvm-memory-management/4.png" alt></p>
<h3 id="老年代中使用串行收集器"><a href="#老年代中使用串行收集器" class="headerlink" title="老年代中使用串行收集器"></a>老年代中使用串行收集器</h3><p>如果使用串行收集器，在老年代和永久代将通过使用 标记 -&gt; 清除 -&gt; 压缩 算法。标记阶段，收集器识别出哪些对象是活的；清除阶段将遍历一下老年代和永久代，识别出哪些是垃圾；然后执行压缩，将活的对象左移到老年代的起始端（永久代类似），这样就留下了右边一片连续可用的空间，后续就可以通过指针碰撞的方式快速分配对象空间。</p>
<p><img src="https://www.javadoop.com/blogimages/jvm-memory-management/5.png" alt></p>
<h3 id="何时应该使用串行收集器"><a href="#何时应该使用串行收集器" class="headerlink" title="何时应该使用串行收集器"></a>何时应该使用串行收集器</h3><p>串行收集器适用于运行在 client 模式下的大部分程序，它们不要求低延时。在现代硬件条件下，串行收集器可以高效管理 64M 堆内存，并且能将 full GC 控制在半秒内完成。</p>
<h3 id="使用串行收集器"><a href="#使用串行收集器" class="headerlink" title="使用串行收集器"></a>使用串行收集器</h3><p>它是 J2SE 5.0 版本 HotSpot 虚拟机在非服务器级别硬件的默认选择。你也可以使用 -XX:+UseSerialGC 来强制使用串行收集器。</p>
<h2 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h2><p>现在大多数 Java 应用都运行在大内存、多核环境中，并行收集器，也就是大家熟知的吞吐量收集器，利用多核的优势来进行垃圾收集，而不是像串行收集器一样将程序挂起后只使用单线程来收集垃圾。</p>
<h3 id="在年轻代中使用并行收集器"><a href="#在年轻代中使用并行收集器" class="headerlink" title="在年轻代中使用并行收集器"></a>在年轻代中使用并行收集器</h3><p>并行收集器在年轻代中其实就是串行收集器收集算法的并行版本。它仍然使用 stop-the-world 和复制算法，只不过使用了多核的优势并行执行，降低垃圾收集的时间，从而提高吞吐量。下图示意了在年轻代中，串行收集器和并行收集器的区别：</p>
<p><img src="https://www.javadoop.com/blogimages/jvm-memory-management/6.png" alt></p>
<h3 id="在老年代中使用并行收集器"><a href="#在老年代中使用并行收集器" class="headerlink" title="在老年代中使用并行收集器"></a>在老年代中使用并行收集器</h3><p>在老年代中，并行收集器使用的是和串行收集器一样的算法：单线程，标记 -&gt; 清除 -&gt; 压缩。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是的，并行收集器只能在年轻代中并行</span><br></pre></td></tr></table></figure>
<h3 id="何时使用并行收集器"><a href="#何时使用并行收集器" class="headerlink" title="何时使用并行收集器"></a>何时使用并行收集器</h3><p>其适用于多核、不要求低停顿的应用，因为老年代的收集虽然不频繁，但是每次老年代的单线程垃圾收集依然可能会需要很长时间。比如说，它可以应用在批处理、账单计算、科学计算等。</p>
<h3 id="使用并行收集器"><a href="#使用并行收集器" class="headerlink" title="使用并行收集器"></a>使用并行收集器</h3><p>前面我们说了，J2SE 5.0 中 client 模式自动选择使用串行收集器，如果是 server 模式，那么将自动使用并行收集器。在其他版本中，显示使用 -XX:+UseParallelGC 可以指定并行收集器。</p>
<h2 id="并行压缩收集器"><a href="#并行压缩收集器" class="headerlink" title="并行压缩收集器"></a>并行压缩收集器</h2><p>并行压缩收集器于 J2SE 5.0 update 6 引入，和并行收集器的区别在于它在老年代也使用并行收集算法。注意：并行压缩收集器终将会取代并行收集器。</p>
<h3 id="在年轻代中使用并行压缩收集器"><a href="#在年轻代中使用并行压缩收集器" class="headerlink" title="在年轻代中使用并行压缩收集器"></a>在年轻代中使用并行压缩收集器</h3><p>并行压缩收集器在年轻代中使用了和并行收集器一样的算法。即使用 并行、stop-the-world、复制 算法。</p>
<h3 id="在老年代中使用并行压缩收集器"><a href="#在老年代中使用并行压缩收集器" class="headerlink" title="在老年代中使用并行压缩收集器"></a>在老年代中使用并行压缩收集器</h3><p>在老年代和永久代中，其使用 并行、stop-the-world、滑动压缩 算法。</p>
<p>一次收集分三个阶段，首先，将老年代或永久代逻辑上分为固定大小的区块。</p>
<ol>
<li><p>标记阶段，将 GC Roots 分给多个垃圾收集线程，每个线程并行地去标记存活的对象，一旦标记一个存活对象，在该对象所在的区块记录这个对象的大小和对象所在的位置。</p>
</li>
<li><p>汇总阶段，此阶段针对区块进行。由于之前的垃圾回收影响，老年代和永久代的左侧是 存活对象密集区，对这部分区域直接进行压缩的代价是不值得的，能清理出来的空间有限。所以第一件事就是，检查每个区块的密度，从左边第一个开始，直到找到一个区块满足：对右侧的所有区块进行压缩获得的空间抵得上压缩它们的成本。这个区块左边的区域过于密集，不会有对象移动到这个区域中。然后，计算并保存右侧区域中每个区块被压缩后的新位置首字节地址。</p>
</li>
</ol>
<p>右侧的区域将被压缩，对于右侧的每个区块，由于每个区块中保存了该区块的存活对象信息，所以很容易计算每个区块的新位置。注意：汇总阶段目前被实现为串行进行，这个阶段修改为并行也是可行的，不过没有在标记阶段和下面的压缩阶段并行那么重要。</p>
<ol start="3">
<li>压缩阶段，在汇总阶段已经完成了每个区块新位置的计算，所以压缩阶段每个回收线程并行将每个区块复制到新位置即可。压缩结束后，就清出来了右侧一大片连续可用的空间。</li>
</ol>
<h3 id="何时使用并行压缩收集器"><a href="#何时使用并行压缩收集器" class="headerlink" title="何时使用并行压缩收集器"></a>何时使用并行压缩收集器</h3><p>首先是多核上的并行优势，这个就不重复了。其次，前面的并行收集器对于老年代和永久代使用串行，而并行压缩收集器在这些区域使用并行，能降低停顿时间。</p>
<p>并行压缩收集器不适合运行在大型共享主机上（如 SunRays），因为它在收集的时候会独占几个 CPU，在这种机器上，可以考虑减少垃圾收集的线程数（通过 –XX:ParallelGCThreads=n），或者就选择其他收集器。</p>
<h3 id="使用并行压缩收集器"><a href="#使用并行压缩收集器" class="headerlink" title="使用并行压缩收集器"></a>使用并行压缩收集器</h3><p>显示指定：-XX:+UseParallelOldGC</p>
<h2 id="Concurrent-Mark-Sweep（CMS）收集器"><a href="#Concurrent-Mark-Sweep（CMS）收集器" class="headerlink" title="Concurrent Mark-Sweep（CMS）收集器"></a>Concurrent Mark-Sweep（CMS）收集器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重头戏 CMS 登场了，至少对于我这个 web 开发者来说，目前 CMS 最常用（使用 JDK8 的应用一般都切换到 G1 收集器了）。前面介绍的都是并行收集，这里要介绍并发收集了，也就是垃圾回收线程和应用程序线程同时运行。</span><br></pre></td></tr></table></figure>
<p>JDK8 一般使用 G1 收集器。</p>
<p>对于许多程序来说，吞吐量不如响应时间来得重要。通常年轻代的垃圾收集不会停顿多长时间，但是，老年代垃圾回收，虽然不频繁，但是可能导致长时间的停顿，尤其当堆内存比较大的时候。为了解决这个问题，HotSpot 虚拟机提供了 CMS 收集器，也叫做 低延时收集器。</p>
<h3 id="在年轻代中使用-CMS-收集器"><a href="#在年轻代中使用-CMS-收集器" class="headerlink" title="在年轻代中使用 CMS 收集器"></a>在年轻代中使用 CMS 收集器</h3><p>在年轻代中，CMS 和 并行收集器 一样，即：并行、stop-the-world、复制。</p>
<h3 id="在老年代中使用-CMS-收集器"><a href="#在老年代中使用-CMS-收集器" class="headerlink" title="在老年代中使用 CMS 收集器"></a>在老年代中使用 CMS 收集器</h3><p>在老年代的垃圾收集过程中，大部分收集任务是和应用程序并发执行的。</p>
<p>CMS 收集过程首先是一段小停顿 stop-the-world，叫做 初始标记阶段（initial mark），用于确定 GC Roots。然后是 并发标记阶段（concurrent mark），标记 GC Roots 可达的所有存活对象，由于这个阶段应用程序同时也在运行，所以并发标记阶段结束后，并不能标记出所有的存活对象。为了解决这个问题，需要再次停顿应用程序，称为 再次标记阶段（remark），遍历在并发标记阶段应用程序修改的对象（标记出应用程序在这个期间的活对象），由于这次停顿比初始标记要长得多，所以会使用多线程并行执行来增加效率。</p>
<p>再次标记阶段结束后，能保证所有存活对象都被标记完成，所以接下来的 并发清理阶段（concurrent sweep） 将就地回收垃圾对象所占空间。下图示意了老年代中 串行、标记 -&gt; 清理 -&gt; 压缩收集器和 CMS 收集器的区别：</p>
<p><img src="https://www.javadoop.com/blogimages/jvm-memory-management/7.png" alt></p>
<p>CMS 收集器是唯一不进行压缩的收集器，在它释放了垃圾对象占用的空间后，它不会移动存活对象到一边去。<br><img src="https://www.javadoop.com/blogimages/jvm-memory-management/8.png" alt></p>
<p>这将节省垃圾回收的时间，但是由于之后空闲空间不是连续的，所以也就不能使用简单的 指针碰撞（bump-the-pointer） 进行对象空间分配了。它需要维护一个 空闲列表，将所有的空闲区域连接起来，当分配空间时，需要寻找到一个可以容纳该对象的区域。显然，它比使用简单的指针碰撞成本要高。同时它也会加大年轻代垃圾收集的负载，因为年轻代中的对象如果要晋升到老年代中，需要老年代进行空间分配。</p>
<p>另外一个缺点就是，CMS 收集器相比其他收集器需要使用更大的堆内存。因为在并发标记阶段，程序还需要执行，所以需要留足够的空间给应用程序。另外，虽然收集器能保证在标记阶段识别出所有的存活对象，但是由于应用程序并发运行，所以刚刚标记的存活对象很可能立马成为垃圾，而且这部分由于已经被标记为存活对象，所以只能到下次老年代收集才会被清理，这部分垃圾称为 浮动垃圾。</p>
<p>最后，由于缺少压缩环节，堆将会出现碎片化问题。为了解决这个问题，CMS 收集器需要追踪统计最常用的对象大小，评估将来的分配需求，可能还需要分割或合并空闲区域。</p>
<p>不像其他垃圾收集器，CMS 收集器不能等到老年代满了才开始收集。否则的话，CMS 收集器将退化到使用更加耗时的 stop-the-world、标记-清除-压缩 算法。为了避免这个，CMS 收集器需要统计之前每次垃圾收集的时间和老年代空间被消耗的速度。另外，如果老年代空间被消耗了 预设占用率（initiating occupancy），也将会触发一次垃圾收集，这个占用率通过 –XX:CMSInitiatingOccupancyFraction=n 进行设置，n 为老年代空间的占用百分比，默认值是 68。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个数字到 Java8 的时候已经变为默认 92 了。如果老年代空间不足以容纳从新生代垃圾回收晋升上来的对象，那么就会发生 concurrent mode failure，此时会退化到发生 Full GC，清除老年代中的所有无效对象，这个过程是单线程的，比较耗时</span><br><span class="line"></span><br><span class="line">另外，即使在晋升的时候判断出老年代有足够的空间，但是由于老年代的碎片化问题，其实最终没法容纳晋升上来的对象，那么此时也会发生 Full GC，这次的耗时将更加严重，因为需要对整个堆进行压缩，压缩后年轻代彻底就空了。</span><br></pre></td></tr></table></figure>
<p>总结下来，和并行收集器相比，CMS 收集器降低了老年代收集时的停顿时间（有时是显著降低），稍微增加了一些年轻代收集的时间、降低了吞吐量 以及 需要更多的堆内存。</p>
<h3 id="增量模式"><a href="#增量模式" class="headerlink" title="增量模式"></a>增量模式</h3><p>CMS 收集器可以使用增量模式，在并发标记阶段，周期性地将自己的 CPU 时钟周期让出来给应用程序。这个功能适用于需要 CMS 的低延时，但是 CPU 核心只有 1 个或 2 个的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">增量模式在 Java8 已经不推荐使用。</span><br><span class="line"></span><br><span class="line">目前我了解到的是，在所有的并发或并行收集器中，都提供了控制垃圾收集线程数量的参数设置。</span><br></pre></td></tr></table></figure></p>
<h3 id="何时使用-CMS-收集器"><a href="#何时使用-CMS-收集器" class="headerlink" title="何时使用 CMS 收集器"></a>何时使用 CMS 收集器</h3><p>适用于应用程序要求低停顿，同时能接受在垃圾收集阶段和垃圾收集线程一起共享 CPU 资源的场景，典型的就是 web 应用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 web 应用中，低延时非常重要，所以 CMS 几乎就是唯一选择，直到后来 G1 的出现。</span><br></pre></td></tr></table></figure></p>
<h3 id="使用-CMS-收集器"><a href="#使用-CMS-收集器" class="headerlink" title="使用 CMS 收集器"></a>使用 CMS 收集器</h3><p>显示指定：-XX:+UseConcMarkSweepGC</p>
<p>如果需要增量模式：–XX:+CMSIncrementalModeoption</p>
<h1 id="GC-触发时机"><a href="#GC-触发时机" class="headerlink" title="GC 触发时机"></a>GC 触发时机</h1><p>什么时候进行垃圾回收？</p>
<h2 id="Minor-GC触发条件"><a href="#Minor-GC触发条件" class="headerlink" title="Minor GC触发条件"></a>Minor GC触发条件</h2><p>当Eden区满时，触发Minor GC。</p>
<h2 id="Full-GC触发条件"><a href="#Full-GC触发条件" class="headerlink" title="Full GC触发条件"></a>Full GC触发条件</h2><ul>
<li><p>调用System.gc时，系统建议执行Full GC，但是不必然执行</p>
</li>
<li><p>老年代空间不足</p>
</li>
<li><p>方法区空间不足</p>
</li>
<li><p>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p>
</li>
<li><p>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
</li>
</ul>
<h1 id="JVM-6-11-默认垃圾回收器"><a href="#JVM-6-11-默认垃圾回收器" class="headerlink" title="JVM 6-11 默认垃圾回收器"></a>JVM 6-11 默认垃圾回收器</h1><ul>
<li>jdk1.7 默认垃圾收集器 Parallel Scavenge（新生代）+ Serial Old（老年代）</li>
<li>jdk1.8 默认垃圾收集器 Parallel Scavenge（新生代）+ Serial Old（老年代）</li>
<li>jdk1.9 默认垃圾收集器 G1</li>
<li>jdk1.10 默认垃圾收集器 G1</li>
<li>jdk1.11 默认垃圾收集器 G1</li>
</ul>
<p>-XX:+PrintCommandLineFlagsjvm参数可查看默认设置收集器类型</p>
<p>-XX:+PrintGCDetails亦可通过打印的GC日志的新生代、老年代名称判断</p>
<p><img src="http://note.youdao.com/yws/res/18836/51D70BBADA52441594797E8CD748FCA8" alt="image"><br>-XX:+UseG1GC：使用 G1 垃圾收集器。</p>
<h2 id="垃圾收集器搭配"><a href="#垃圾收集器搭配" class="headerlink" title="垃圾收集器搭配"></a>垃圾收集器搭配</h2><p>垃圾收集器:</p>
<ul>
<li>新生代收集器: Serial, ParNew, Parallel Scavenge (MaxGCPauseMillis vs. GCTimeRatio 响应时间 vs. 吞吐量)</li>
<li>老生代收集器: Serial Old, Parallel Old, CMS</li>
</ul>
<p>垃圾收集器搭配总结:</p>
<ul>
<li>CMS 只能配 Serial 或 ParNew</li>
<li>Parallel Scavenge 只能配 Serial Old 或 Parallel Old</li>
<li>Serial 不能配 Parallel Old</li>
<li>ParNew 不能搭配 Parallel Old</li>
</ul>
<p>搭配种类：</p>
<ul>
<li>Serial + Serial Old (UseSerialGC): GC 线程在做事情时, 其他所有的用户线程都必须停止 (即 stop the world)</li>
<li>Serial + CMS: 一般不会这样配合使用</li>
<li>ParNew + CMS (UseConcMarkSweepGC): 新生代的 GC 使用 ParNew, 有多个 GC 线程同时进行 Minor GC (主要是在多核的环境用多线程效果会好); 而老生代使用 CMS (CMS 后面会重点讲)</li>
<li>ParNew + Serial Old (UseParNewGC): 新生代用 ParNew 的时候, 也可以选择老生代不用 CMS, 而用 Serial Old (实际上, 这个组合也不太常用)</li>
<li>Parallel Scavenge + Serial Old (UseParallelGC): Parallel Scavenge 收集器的目的是达到一个可控制的吞吐率 (适用于各种计算任务); 这个组合中老生代仍旧使用 Serial Old</li>
<li>Parallel Scavenge + Parallel Old (UseParallelOldGC): 新生代使用 Parallel Scavenge, 而 Parallel Old 是老年代版本的 Parallel Scavenge</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行or并发</th>
<th>新生代/老年代</th>
<th>算法</th>
<th>目标</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial</td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td>CMS</td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除</td>
<td>响应速度优先</td>
<td>集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td>G1</td>
<td>并发</td>
<td>both</td>
<td>标记-整理+复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用，将来替换CMS</td>
</tr>
</tbody>
</table>
<p>ParNew 和 Parallel Scavenge 区别：</p>
<ul>
<li>两者都是复制算法，都是并行处理，但是不同的是，paralel scavenge 可以设置最大gc停顿时间（-XX:MaxGCPauseMills）以及gc时间占比(-XX:GCTimeRatio)</li>
<li>说明：</li>
<li>GCTimeRatio参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1 /（1+19）），默认值为99，就是允许最大1%（即1 /（1+99））的垃圾收集时间。</li>
<li>MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>串行收集器：在年轻代和老年代都采用单线程，年轻代中使用 stop-the-world、复制 算法；老年代使用 stop-the-world、标记 -&gt; 清理 -&gt; 压缩 算法。</p>
<p>适用情况：数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用</p>
<p>并行收集器：在年轻代中使用 并行、stop-the-world、复制 算法；老年代使用串行收集器的 串行、stop-the-world、标记 -&gt; 清理 -&gt; 压缩 算法。</p>
<p>适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。</p>
<p>并行压缩收集器：在年轻代中使用并行收集器的 并行、stop-the-world、复制 算法；老年代使用 并行、stop-the-world、标记 -&gt; 清理 -&gt; 压缩 算法。和并行收集器的区别是老年代使用了并行。</p>
<p>CMS 收集器：在年轻使用并行收集器的 并行、stop-the-world、复制 算法；老年代使用 并发、标记 -&gt; 清理 算法，不压缩。本文介绍的唯一一个并发收集器，也是唯一一个不对老年代进行压缩的收集器。</p>
<p>适用情况：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.javadoop.com/post/jvm-memory-management" target="_blank" rel="noopener">Hotspot JVM 内存管理</a></li>
<li><a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">官方垃圾收集器策略</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JVM/" rel="tag"># JVM</a>
          
        </div>
      

      
      
      

      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
      <div id="gitalk-container"></div>



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zeusoul</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾收集概念"><span class="nav-number">1.</span> <span class="nav-text">垃圾收集概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器的理想特征"><span class="nav-number">1.1.</span> <span class="nav-text">垃圾收集器的理想特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计上的权衡"><span class="nav-number">1.2.</span> <span class="nav-text">设计上的权衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能指标"><span class="nav-number">1.3.</span> <span class="nav-text">性能指标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分代收集介绍"><span class="nav-number">1.4.</span> <span class="nav-text">分代收集介绍</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#J2SE-5-0-HotSpot-JVM-中的垃圾收集器"><span class="nav-number">2.</span> <span class="nav-text">J2SE 5.0 HotSpot JVM 中的垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HotSpot-分代"><span class="nav-number">2.1.</span> <span class="nav-text">HotSpot 分代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收类型"><span class="nav-number">2.2.</span> <span class="nav-text">垃圾回收类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速分配"><span class="nav-number">2.3.</span> <span class="nav-text">快速分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#串行收集器"><span class="nav-number">2.4.</span> <span class="nav-text">串行收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#年轻代中使用串行收集器"><span class="nav-number">2.4.1.</span> <span class="nav-text">年轻代中使用串行收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#老年代中使用串行收集器"><span class="nav-number">2.4.2.</span> <span class="nav-text">老年代中使用串行收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#何时应该使用串行收集器"><span class="nav-number">2.4.3.</span> <span class="nav-text">何时应该使用串行收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用串行收集器"><span class="nav-number">2.4.4.</span> <span class="nav-text">使用串行收集器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并行收集器"><span class="nav-number">2.5.</span> <span class="nav-text">并行收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在年轻代中使用并行收集器"><span class="nav-number">2.5.1.</span> <span class="nav-text">在年轻代中使用并行收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在老年代中使用并行收集器"><span class="nav-number">2.5.2.</span> <span class="nav-text">在老年代中使用并行收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#何时使用并行收集器"><span class="nav-number">2.5.3.</span> <span class="nav-text">何时使用并行收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用并行收集器"><span class="nav-number">2.5.4.</span> <span class="nav-text">使用并行收集器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并行压缩收集器"><span class="nav-number">2.6.</span> <span class="nav-text">并行压缩收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在年轻代中使用并行压缩收集器"><span class="nav-number">2.6.1.</span> <span class="nav-text">在年轻代中使用并行压缩收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在老年代中使用并行压缩收集器"><span class="nav-number">2.6.2.</span> <span class="nav-text">在老年代中使用并行压缩收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#何时使用并行压缩收集器"><span class="nav-number">2.6.3.</span> <span class="nav-text">何时使用并行压缩收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用并行压缩收集器"><span class="nav-number">2.6.4.</span> <span class="nav-text">使用并行压缩收集器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Concurrent-Mark-Sweep（CMS）收集器"><span class="nav-number">2.7.</span> <span class="nav-text">Concurrent Mark-Sweep（CMS）收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在年轻代中使用-CMS-收集器"><span class="nav-number">2.7.1.</span> <span class="nav-text">在年轻代中使用 CMS 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在老年代中使用-CMS-收集器"><span class="nav-number">2.7.2.</span> <span class="nav-text">在老年代中使用 CMS 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增量模式"><span class="nav-number">2.7.3.</span> <span class="nav-text">增量模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#何时使用-CMS-收集器"><span class="nav-number">2.7.4.</span> <span class="nav-text">何时使用 CMS 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-CMS-收集器"><span class="nav-number">2.7.5.</span> <span class="nav-text">使用 CMS 收集器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GC-触发时机"><span class="nav-number">3.</span> <span class="nav-text">GC 触发时机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Minor-GC触发条件"><span class="nav-number">3.1.</span> <span class="nav-text">Minor GC触发条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Full-GC触发条件"><span class="nav-number">3.2.</span> <span class="nav-text">Full GC触发条件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM-6-11-默认垃圾回收器"><span class="nav-number">4.</span> <span class="nav-text">JVM 6-11 默认垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器搭配"><span class="nav-number">4.1.</span> <span class="nav-text">垃圾收集器搭配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">5.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zeusoul</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: 'c04df7c69d5761801385',
          clientSecret: '5fb09dba6d14aa370d23a46ad1d2ffec28532c57',
          repo: 'zeusoul.github.io',
          owner: 'zeusoul',
          admin: ['zeusoul'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
